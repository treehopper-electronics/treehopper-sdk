using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

namespace Treehopper
{
    /// <summary>
    /// Defines whether a signal is active high (rising-edge) or active low (falling-edge)
    /// </summary>
    public enum PinPolarity
    {

        /// <summary>
        /// The signal is considered active when the signal is low
        /// </summary>
        ActiveLow,
        /// <summary>
        /// The signal is considered active when the signal is high
        /// </summary>
        ActiveHigh
    };

    public enum AdcReferenceLevel
    {
        /// <summary>
        /// 3.3V rail generated by on-board LDO, rated at 1.5% accuracy.
        /// </summary>
        VREF_3V3,

        /// <summary>
        /// 1.65V reference rated at 1.8% accuracy. 
        /// </summary>
        VREF_1V65,

        /// <summary>
        /// 1.8V reference. Accuracy TBD.
        /// </summary>
        VREF_1V8,

        /// <summary>
        /// 2.4V reference rated at 2.1% accuracy.
        /// </summary>
        VREF_2V4,

        /// <summary>
        /// 3.3V supply derived from the 1.65V reference rated at 3.6% accuracy.
        /// </summary>
        VREF_3V3_DERIVED,

        /// <summary>
        /// 3.6V reference derived from the 1.8V LDO. Accuracy TBD.
        /// </summary>
        VREF_3V6

        // These are pointless, since ADC voltage is clamped to 3.6V
        //VREF_4V8,
        //VREF_6V6,
    }

    /// <summary>
    /// This is the delegate prototype used for event-driven reading of digital pins.
    /// </summary>
    /// <param name="sender">The Pin that changed</param>
    /// <param name="value">The new value of the pin</param>
    public delegate void OnDigitalInValueChanged(Pin sender, bool value);

    internal enum PinConfigCommands
    {
        MakeDigitalInput = 0x00,
        MakePushPullOutput,
        MakeOpenDrainOutput,
        MakeAnalogInput,
        SetDigitalValue,
        GetDigitalValue,
        GetAnalogValue
    }

    public enum PinMode { Reserved, DigitalInput, PushPullOutput, OpenDrainOutput, AnalogInput, Unassigned };
    
    ///// <summary>
    ///// The interrupt mode of the pin.
    ///// </summary>
    //public enum PinInterruptMode {
    //    /// <summary>
    //    /// Interrupts disabled.
    //    /// </summary>
    //    NoInterrupt, 
        
    //    /// <summary>
    //    /// Interrupt occurs when pin transitions from low to high.
    //    /// </summary>
    //    Rising, 
        
    //    /// <summary>
    //    /// Interrupt occurs when pin transitions from high to low
    //    /// </summary>
    //    Falling, 
        
    //    /// <summary>
    //    /// Interrupt occurs when pin transitions from either low to high, or from high to low.
    //    /// </summary>
    //    RisingFalling 
    //};

    public enum OutputType
    {
        PushPull,

        OpenDrain
    }

    /// <summary>
    /// Used to send VoltageChanged events from the AnalogIn pin.
    /// </summary>
    /// <param name="sender">The AnalogIn pin that sent that message</param>
    /// <param name="voltage">The new voltage of the AnalogIn pin</param>
    public delegate void OnAnalogVoltageChanged(Pin sender, double voltage);

    /// <summary>
    /// Used to send ValueChanged events from the AnalogIn pin.
    /// </summary>
    /// <param name="sender">The AnalogIn pin that sent that message</param>
    /// <param name="value">The new voltage of the AnalogIn pin</param>
    public delegate void OnAdcValueChanged(Pin sender, int value);

    /// <summary>
    /// Used to send ValueChanged events from the pin.
    /// </summary>
    /// <param name="sender">The pin that sent that message</param>
    /// <param name="value">The new normalized value of the pin</param>
    public delegate void OnAnalogValueChanged(Pin sender, double value);

    /// <summary>
    /// Pin is the base class for all Treehopper pins. It provides core digital I/O (GPIO) functionality.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class is useful when only core GPIO functions are needed, and the user wishes to make code portable
    /// between pins. While it cannot be instantiated directly by the user, Pin variables can reference existing pins.
    /// </para>
    /// </remarks>
    public class Pin : INotifyPropertyChanged, IDigitalPin, IAdcPin
    {
        protected string ioName;
        /// <summary>
        /// The PIC16F1459 pin name
        /// </summary>
        public string IOName { get { return ioName; } }

        private TreehopperUsb board;
        /// <summary>
        /// This returns a reference to the Treehopper board this pin belongs to.
        /// </summary>
        public TreehopperUsb Board { get { return board; } }

        bool digitalValue;

        private PinMode mode = PinMode.Unassigned;
        public PinMode Mode
        {
            get
            {
                return mode;
            }
            set
            {
                if (value == mode)
                    return;
                if(mode == PinMode.Reserved && value != PinMode.Unassigned)
                {
                    throw new Exception("This pin is reserved; you must disable the peripheral using it before interacting with it");
                }

                mode = value;

                switch (mode)
                {
                    case PinMode.AnalogInput:
                        SendCommand(new byte[] { (byte)PinConfigCommands.MakeAnalogInput, (byte)ReferenceLevel });
                        break;
                    case PinMode.DigitalInput:
                        SendCommand(new byte[] { (byte)PinConfigCommands.MakeDigitalInput, 0x00 });
                        break;
                    case PinMode.OpenDrainOutput:
                        SendCommand(new byte[] { (byte)PinConfigCommands.MakeOpenDrainOutput, 0x00 });
                        break;
                    case PinMode.PushPullOutput:
                        SendCommand(new byte[] { (byte)PinConfigCommands.MakePushPullOutput, 0x00 });
                        break;
                }


            }
        }

        /// <summary>
        /// Occurs when the input on the pin changes.
        /// </summary>
        /// <remarks>
        /// This event will only fire when the pin is configured as a digital input.
        /// </remarks>
        public event OnDigitalInValueChanged DigitalValueChanged;

        /// <summary>
        /// The pin number of the pin.
        /// </summary>
        public int PinNumber { get; set; }

        /// <summary>
        /// The SoftPwm functions associated with this pin.
        /// </summary>
        public SoftPwm SoftPwm { get; set;}
        
        internal Pin(TreehopperUsb board, byte pinNumber)
        {
            this.board = board;
            this.PinNumber = pinNumber;
            SoftPwm = new SoftPwm(Board, this);
            AdcValueChangedThreshold = 10;
            AnalogVoltageChangedThreshold = 0.1;
            AnalogValueChangedThreshold = 0.05;
            this.ReferenceLevel = AdcReferenceLevel.VREF_3V3;
        }

        /// <summary>
        /// Gets or sets the voltage threshold required to fire the AnalogVoltageChanged event.
        /// </summary>
        public double AnalogVoltageChangedThreshold { get; set; }
        
        /// <summary>
        /// Gets or sets the value threshold required to fire the AdcValueChanged event.
        /// </summary>
        public int AdcValueChangedThreshold { get; set; }

        /// <summary>
        /// Gets or sets the value threshold required to fire the AnalogValueChanged event.
        /// </summary>
        public double AnalogValueChangedThreshold { get; set; }

        /// <summary>
        /// Gets or sets the digital value of the pin.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Setting a value to a pin that is configured as an input will automatically make the pin an output before 
        /// writing the value to it. 
        /// </para>
        /// <para>
        /// The value retrieved from this pin will read as "0" when then pin is being used for other purposes.
        /// </para>
        /// </remarks>
        public bool DigitalValue
        {
            get
            {
                return digitalValue;
            }
            set
            {
                digitalValue = value;
                if (!(Mode == PinMode.PushPullOutput || Mode == PinMode.OpenDrainOutput))
                    Mode = PinMode.PushPullOutput; // assume they want push-pull
                byte byteVal = (byte)(digitalValue ? 0x01 : 0x00);
                SendCommand(new byte[] { (byte)PinConfigCommands.SetDigitalValue, byteVal});
            }
        }

        /// <summary>
        /// Toggles the output value of the pin.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Calling this function on a pin that is configured as an input will automatically make the pin an output
        /// before writing the value to it.
        /// </para>
        /// </remarks>
        /// <example>
        /// In this example, an LED attached to pin 4 is made to blink.
        /// <code>
        /// Pin led = myTreehopperBoard.Pin4; // create a reference to Pin4 to keep code concise.
        /// led.MakeDigitalOutput();
        /// while(true)
        /// {
        ///     led.Toggle();
        ///     Thread.Sleep(500);
        /// }
        /// </code>
        /// </example>
        public void ToggleOutput()
        {
            DigitalValue = !DigitalValue;
        }


        TaskCompletionSource<bool> digitalSignal = new TaskCompletionSource<bool>();
        public Task<bool> AwaitDigitalValueChange()
        {
            digitalSignal = new TaskCompletionSource<bool>();
            return digitalSignal.Task;
        }

        TaskCompletionSource<int> adcValueSignal = new TaskCompletionSource<int>();
        TaskCompletionSource<double> analogValueSignal = new TaskCompletionSource<double>();
        TaskCompletionSource<double> analogVoltageSignal = new TaskCompletionSource<double>();

        public Task<int> AwaitAdcValueChange()
        {
            adcValueSignal = new TaskCompletionSource<int>();
            return adcValueSignal.Task;
        }

        public Task<double> AwaitAnalogVoltageChange()
        {
            analogVoltageSignal = new TaskCompletionSource<double>();
            return analogVoltageSignal.Task;
        }

        public Task<double> AwaitAnalogValueChange()
        {
            analogValueSignal = new TaskCompletionSource<double>();
            return analogValueSignal.Task;
        }

        internal void RaiseDigitalInValueChanged()
        {
            DigitalValueChanged?.Invoke(this, digitalValue);

            digitalSignal.TrySetResult(digitalValue);
        }

        internal void RaiseAnalogInChanged()
        {
            if (Math.Abs(prevAdcValue - adcValue) > AdcValueChangedThreshold)
            {
                prevAdcValue = adcValue;
                AdcValueChanged?.Invoke(this, adcValue);

                adcValueSignal.TrySetResult(adcValue);

                RaisePropertyChanged("AdcValue");
            }

            if (Math.Abs(prevAnalogVoltage - AnalogVoltage) > AnalogVoltageChangedThreshold)
            {
                prevAnalogVoltage = AnalogVoltage;
                AnalogVoltageChanged?.Invoke(this, AnalogVoltage);

                analogVoltageSignal.TrySetResult(AnalogVoltage);

                RaisePropertyChanged("AnalogVoltage");
            }

            if(Math.Abs(prevAnalogValue - AnalogValue) > AnalogValueChangedThreshold)
            {
                prevAnalogValue = AnalogValue;
                AnalogValueChanged?.Invoke(this, AnalogValue);

                analogValueSignal.TrySetResult(AnalogValue);

                RaisePropertyChanged("AnalogValue");
            }
        }

        internal void SendCommand(byte[] cmd)
        {
            byte[] data = new byte[6];
            data[0] = (byte)PinNumber;
            cmd.CopyTo(data, 1);
            Board.sendPinConfigPacket(data);
        }

        private int prevAdcValue;
        private double prevAnalogVoltage;
        private double prevAnalogValue;

        internal virtual void UpdateValue(byte highByte, byte lowByte)
        {
            if(Mode == PinMode.DigitalInput)
            {
                bool newVal = highByte > 0;
                if (digitalValue != newVal) // we have a new value!
                {
                    digitalValue = newVal;
                    RaiseDigitalInValueChanged();
                    RaisePropertyChanged("DigitalValue");
                }
            } else if(Mode == PinMode.AnalogInput)
            {
                int val = ((int)highByte) << 8;
                val |= (int)lowByte;
                adcValue = val;
                RaiseAnalogInChanged();
            }
            
        }

        /// <summary>
        /// Occurs when an analog voltage is changed, according to the set threshold.
        /// </summary>
        /// <remarks>
        /// The Changed event is raised when the 12-bit ADC value obtained is different from the previous reading 
        /// by at least the value specified by <see cref="AnalogVoltageChangedThreshold"/>.
        /// </remarks>
        public event OnAnalogVoltageChanged AnalogVoltageChanged;

        /// <summary>
        /// Occurs when an analog value is changed, according to the set threshold.
        /// </summary>
        /// <remarks>
        /// The Changed event is raised when the 10-bit ADC value obtained is different from the previous reading
        /// by at least the value specified by <see cref="AdcValueChangedThreshold"/>
        /// </remarks>
        public event OnAnalogValueChanged AnalogValueChanged;

        /// <summary>
        /// Occurs when the normalized analog value is changed, according to the set threshold.
        /// </summary>
        /// <remarks>
        /// The Changed event is raised when the 10-bit ADC value obtained is different from the previous reading.
        /// </remarks>
        public event OnAdcValueChanged AdcValueChanged;


        int adcValue;

        /// <summary>
        /// Retrieve the last value obtained from the ADC. 
        /// </summary>
        /// <remarks>
        /// Treehopper has a 12-bit ADC, so ADC values will range from 0-4092.
        /// </remarks>
        public int AdcValue
        {
            get
            {
                return adcValue;
            }
        }

        /// <summary>
        /// Retrieve the last voltage reading from the ADC.
        /// </summary>
        public double AnalogVoltage
        {
            get
            {
                return Math.Round((double)AdcValue * (referenceLevelVoltage / 4092.0), 4);
            }
        }

        /// <summary>
        /// Retrieve the last reading from the ADC, expressed on a unit range (0.0 - 1.0)
        /// </summary>
        /// <remarks>
        /// </remarks>
        public double AnalogValue
        {
            get
            {
                return Math.Round((double)AdcValue / 4092.0, 4);
            }
        }

        double referenceLevelVoltage;

        AdcReferenceLevel referenceLevel;

        /// <summary>
        /// Sets the ADC reference value used 
        /// </summary>
        public AdcReferenceLevel ReferenceLevel
        {
            get
            {
                return referenceLevel;
            }
            set
            {
                referenceLevel = value;
                switch(referenceLevel)
                {
                    case AdcReferenceLevel.VREF_1V65:
                        referenceLevelVoltage = 1.65;
                        break;
                    case AdcReferenceLevel.VREF_1V8:
                        referenceLevelVoltage = 1.8;
                        break;
                    case AdcReferenceLevel.VREF_2V4:
                        referenceLevelVoltage = 2.4;
                        break;
                    case AdcReferenceLevel.VREF_3V3:
                        referenceLevelVoltage = 3.3;
                        break;
                    case AdcReferenceLevel.VREF_3V3_DERIVED:
                        referenceLevelVoltage = 3.3;
                        break;
                    case AdcReferenceLevel.VREF_3V6:
                        referenceLevelVoltage = 3.6;
                        break;
                }

                // if we're already an analog input, re-send the command to set the new reference level
                if (Mode == PinMode.AnalogInput)
                    SendCommand(new byte[] { (byte)PinConfigCommands.MakeAnalogInput, (byte)ReferenceLevel });
            }
        }

        /// <summary>
        /// This event fires whenever a property changes
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        internal void RaisePropertyChanged(string property)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(property));
        }

        public void MakeDigitalPushPullOut()
        {
            Mode = PinMode.PushPullOutput;
        }

        public void MakeDigitalIn()
        {
            Mode = PinMode.DigitalInput;
        }

        public void MakeAnalogIn()
        {
            Mode = PinMode.AnalogInput;
        }
    }
}
